import {
    boundInnerRadius,
    boundOuterRadius,
} from "../shapeConstants";
import { changeHistoryProp, changeHistoryStyle } from "../actions/changeHistoryProp";

export default class AbstractHistory {
    constructor (id){
        this.id = id;

        if (new.target === AbstractHistory) {
            throw new TypeError(`Cannot create an abstract history directly.`);
        }

        if (this.shape === undefined) {
            throw new TypeError(`Must define 'shape' parameter with a name constant`);
        }

        if (this.form === undefined) {
            throw new TypeError(`Must define 'form' parameter with a shape form`);
        }

        if (this.stateToPropsMap === undefined) {
            throw new TypeError(`Must define 'stateToPropsMap' function that accepts a state and returns a stateToProps map`);
        }

        if (this.dispatchToPropsMap === undefined) {
            throw new TypeError(`Must define 'dispatchToPropsMap' function that accepts a dispatch and returns a dispatchToProps map`);
        }
    }

    stateToProps() {
        /*
        https://github.com/davidhatten/geometric-drawer/issues/62

        The try/catch is here to fix the above bug. If you redesign the Edit pane, investigate changing this
        Basically what happens is that Popovers generated by antd somehow get left around and mapped to stale items
        For some reason, when these stale Popovers have more than one item in the History, it fixes itself
        But when there's only one item left in the History, the whole page crashes on hover or selected shape change
         */
        return state => {
            try {
                return this.stateToPropsMap(state);
            } catch (error) {
                return {};
            }
        };
    }

    dispatchToProps() {
        return dispatch => this.dispatchToPropsMap(dispatch);
    }

    universalProps(state) {
        return {
            lineWidth: this.lineWidthState(state, this.id),
            fillShape: state.shapeStyle.byId[this.id].fill !== `none`,
            ...this.positionProps(state.shapeProps.byId, this.id),
        };
    }

    universalDispatch(dispatch) {
        return {
            ...this.historyPositionDispatch(dispatch, this.id),
            updateLineWidth: this.lineWidthDispatch(dispatch, this.id),
            toggleFillShape: (checked) => (dispatch(changeHistoryStyle(this.id, `fill`, checked ? `white` : `none`))),
        };
    }

    historyPositionDispatch(dispatch, id) {
        return {
            updateXPos: value => {dispatch(changeHistoryProp(id, `x`, parseInt(value)));},
            updateYPos: value => {dispatch(changeHistoryProp(id, `y`, parseInt(value)));},
        };
    }

    basicHistoryDispatch(dispatch, id) {
        return {
            ...this.historyRingDispatchWithNoValidation(dispatch, id),
            updateInnerRadius: value => {
                dispatch(this.changeHistoryInnerRadius(id, value));
            },
            updateOuterRadius: value => {
                dispatch(this.changeHistoryOuterRadius(id, value));
            },
        };
    }

    manualHistorySingleControlPointRingDispatch(dispatch, id) {
        return {
            ...this.noControlBasicHistoryRingDispatch(dispatch, id),
            updateInnerXLeftControl: value => {
                dispatch(changeHistoryProp(id, `innerXLeftControl`, value));
            },
            updateInnerXRightControl: value => {
                dispatch(changeHistoryProp(id, `innerXRightControl`, value));
            },
            updateInnerYLeftControl: value => {
                dispatch(changeHistoryProp(id, `innerYLeftControl`, value));
            },
            updateInnerYRightControl: value => {
                dispatch(changeHistoryProp(id, `innerYRightControl`, value));
            },
        };
    }

    historyRingDispatchWithNoValidation(dispatch, id) {
        return {
            updateInnerXControl: value => {
                dispatch(changeHistoryProp(id, `innerXControl`, value));
            },
            updateInnerYControl: value => {
                dispatch(changeHistoryProp(id, `innerYControl`, value));
            },
            ...this.noControlBasicHistoryRingDispatch(dispatch, id),
        };
    }

    noControlBasicHistoryRingDispatch(dispatch, id) {
        return {
            updateAxes: value => {
                dispatch(changeHistoryProp(id, `axes`, value));
            },
            updateInnerGap: value => {
                dispatch(changeHistoryProp(id, `innerGap`, value));
            },
            updateOuterGap: value => {
                dispatch(changeHistoryProp(id, `outerGap`, value));
            },
            updateRotation: value => {
                dispatch(changeHistoryProp(id, `rotation`, value));
            },
            updateInnerRadius: value => {
                dispatch(this.changeHistoryInnerRadius(id, value));
            },
            updateOuterRadius: value => {
                dispatch(this.changeHistoryOuterRadius(id, value));
            },
        };
    }

    changeHistoryInnerRadius(id, value) {
        return (dispatch, getState) => {
            const state = getState();
            const outerRadius = state.shapeProps.byId[id].outerRadius;

            dispatch(changeHistoryProp(id, `innerRadius`, boundInnerRadius(value, outerRadius)));
        };
    };

    changeHistoryOuterRadius(id, value) {
        return (dispatch, getState) => {
            const state = getState();
            const innerRadius = state.shapeProps.byId[id].innerRadius;

            dispatch(changeHistoryProp(id, `outerRadius`, boundOuterRadius(value, innerRadius)));
        };
    }

    positionProps(state, config) {
        return {
            x: this.xPosState(state, config),
            y: this.yPosState(state, config),
        };
    }

    xPosState(state, id) {
        return state[id].x;
    }

    yPosState(state, id) {
        return state[id].y;
    }


    lineWidthState(state, id) {
        return state.shapeStyle.byId[id].strokeWidth;
    }

    lineWidthDispatch(dispatch, id) {
        return (value) => (
            dispatch(changeHistoryStyle(id, `strokeWidth`, parseInt(value)))
        );
    }
}